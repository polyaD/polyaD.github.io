---
title:  Leetcode Mr.How知其所以然之动态规划算法Leetcode归集主题模块
layout: post
categories: Algorithm
tags: Leetcode
excerpt: Leetcode 动态规划算法归集主题模块
---
# DP动态规划算法Leetcode归集主题模块  <span id="home">

---

原创文章，版权所有，搬运文章，转发请注明polyaD，原文链接<https://polyad.github.io/tags>
如有任何问题或疑惑，请在后面留言或者发邮箱留言polyaluthor@gmail.com，或者微信群，qq1183780343进行探讨。

---
**前言**  
&emsp;&emsp;您好，欢迎来到我的引导学习记录博客，我是polayD, Mr.How先生。本系列依据《怎样解题》，George Polya的方法以及知其所以然模式启发，进行拓展而成。希望在这里，您能找到引导式学习的快乐，逐步建立与形成自己的知识同化模式，摆脱碎片化信息的烦扰，掌握快速学习与深度知识系统化的技能，期待与您共同进步。
&emsp;&emsp;信息碎片化的时代，大部分人只能随波逐流，特别是当没有形成系统化的知识模块，很多时候我们只能人云亦云，面对海量信息，无法判别重要性，相关性，有效性，普通的个人很难在信息洪流中找到自己的定位。深度式的知其所以然的引导式学习，可避开信息碎片化旋涡，同时突破信息茧房的束缚。下面波利亚将引领您，进入一个这个基础主题模块的海洋，带上自己的定位导航，抓紧好奇心的船舵，扬帆深入得在这片海洋里探索，前进，自我迭代进化。  
****理念****  
&emsp;首先，做什么事之前，先要设定一下我们的小目标，
我们的整体导航路径：
1.主题解析，先难后易，深入浅出，案例拆解，举一反三  
2.主要解决两个问题：如何思考这个分支限界法算法？如何使用这个分支限界法算法解决问题？  
3.尽可能所有收集参考资料，全部用自己的语言进行复述回答。  
4.提供中英文版本
**系列基础模块定位**      
&emsp;
将如下基础主题模块化  
 
****掌握的路径框架****
# 目录
* **[I ](#1)**      
动态规划算法归集

- - Minimum (Maximum) Path to Reach a Target(到达目标的最值路径)  
- - Distinct Ways(达到目标的不同方式总数)  
- - Merging Intervals(区间合并)  
- - DP on Strings(处理字符串的DP)  
- - Decision Making(取舍决定)  

#####  215 DP problems list  

- - 1.Linear DP  
- - 2.Knapsack
- - 3.Multi Dimensions DP
- - 4.Interval DP
- - 5.bit DP  
- - 6.Digit DP  
- - 7.DP on Trees  
- - 8.String DP  
- - 9.Probability DP  
- - 10.Classic DPs 
A.Cadane's Algorithm  
B.LCS  
C.LIS  
D.2D Grid Traversal  
E.Cumulative Sum  
F.Hashmap (SubArray) 
- - 11.DP + Alpha (Tricks/DS)  
- - 12.Insertion DP  
- - 13.Graph DP  
- - 14.Memoization  
- - 15.Binary Lifting  
- - -16.Math  


#####  动态规划算法归集
个人总结：
1.可选择，条件选择和最值选择。
- 特征描述 
- - Minimum (Maximum) Path to Reach a Target(到达目标的最值路径)  
    给定一个目标，找出其最值路径，成本，总数等。
- - Distinct Ways(达到目标的不同方式总数)  
    获取达到当前状态的所有方式总数  
- - Merging Intervals(区间合并)  
    从左边与右边的区间获取最优解  
- - DP on Strings(处理字符串的DP)  
    处理两个字符串的关系，根据条件选择结果。
- - Decision Making(取舍决定)   
    给定一列数值，选择查找一个答案，选择或忽视当前值

- 解题模板   
- - Minimum (Maximum) Path to Reach a Target(到达目标的最值路径)  
最优子结构：调用最值函数，在多个结果中选择极值，max,min,sum    
```cpp
routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]
```
选择最优的值，返回
```cpp
for (int i = 1; i <= target; ++i) {
   for (int j = 0; j < ways.size(); ++j) {
       if (ways[j] <= i) {
           dp[i] = min(dp[i], dp[i - ways[j]]) + cost / path / sum;
       }
   }
}
 
return dp[target]
```


- - Distinct Ways(达到目标的不同方式总数)

```cpp
routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k]
```  

```cpp
for (int i = 1; i <= target; ++i) {
   for (int j = 0; j < ways.size(); ++j) {
       if (ways[j] <= i) {
           dp[i] += dp[i - ways[j]];
       }
   }
}
 
return dp[target]
```
- - Merging Intervals(区间合并)  

```cpp
// from i to j
dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]
```

```cpp
for(int l = 1; l<n; l++) {
   for(int i = 0; i<n-l; i++) {
       int j = i+l;
       for(int k = i; k<j; k++) {
           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);
       }
   }
}
 
return dp[0][n-1]
```
- - DP on Strings(处理字符串的DP)  


```cpp
// i - indexing string s1
// j - indexing string s2
for (int i = 1; i <= n; ++i) {
   for (int j = 1; j <= m; ++j) {
       if (s1[i-1] == s2[j-1]) {
           dp[i][j] = /*code*/;
       } else {
           dp[i][j] = /*code*/;
       }
   }
}
```

- - Decision Making(取舍决定) 

```cpp
// i - indexing a set of values
// j - options to ignore j values
for (int i = 1; i < n; ++i) {
   for (int j = 1; j <= k; ++j) {
       dp[i][j] = max({dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]});
       dp[i][j-1] = max({dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]});
   }
}
```


 

 




-----
#参考资料  
-----  
一级资料文献与书籍及重要作者  
文献：  
书籍：  
博客：[Dynamic Programming Patterns](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns)   
[Back Solved all dynamic programming (dp) problems in 7 months.](https://leetcode.com/discuss/general-discussion/1000929/solved-all-dynamic-programming-dp-problems-in-7-months)  
论坛：   
视频：  

二级资料：他人加工且有观点及大众资料  
博客： 
论坛：   
视频：    



-----

# **返回[顶部](#home)**

---- 