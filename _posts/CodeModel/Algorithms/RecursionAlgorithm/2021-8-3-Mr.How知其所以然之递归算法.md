---
title:  Algorithm Mr.How知其所以然之递归算法
layout: post
categories: 主题算法
tags: Algorithm
excerpt: 递归算法主题模块
---
# Algorithm Mr.How知其所以然之递归算法 <span id="home">

---

原创文章，版权所有，搬运文章，转发请注明polyaD，原文链接<https://polyad.github.io/tags>
如有任何问题或疑惑，请在后面留言或者发邮箱留言polyaluthor@gmail.com，加微信polyad或者qq数学算法开发10群 282642152进行探讨,请备注：Mr.How。   

---
**前言**  
&emsp;&emsp;您好，欢迎来到我的引导学习记录笔记，我是polayD, Mr.How先生。本系列依据《怎样解题》，George Polya的方法以及知其所以然模式启发，进行拓展而成。希望在这里，您能找到引导式学习的快乐，逐步建立与形成自己的知识同化模式，摆脱碎片化信息的烦扰，掌握快速学习与深度知识系统化的技能，期待与您共同进步。  
&emsp;&emsp;信息碎片化的时代，随波逐流我们将一无所获，特别是当没有形成系统垂直化的知识模块，很多时候我们只能人云亦云，面对海量信息，无法判别重要性，相关性，有效性，普通的个人很难在信息洪流中找到自己的定位。深度式的知其所以然的引导式学习，可避开信息碎片化旋涡，同时突破信息茧房的束缚。下面波利亚将引领您，进入一个这个基础主题模块的海洋，带上自己的定位导航，抓紧好奇心的船舵，扬帆深入得在这片海洋里探索，前进，自我迭代进化。    
****理念与标准设定迭代模块****  
I.理念迭代：  
1.缝合现实与理论的鸿沟。    
2.缝合理论主题与练习的鸿沟。   
3.认知升级：掌握方法论比掌握知识点更重要。    
4.设立量化目标：标准框架与计划实施作业，建立模块化迭代。  
5.潜意识出发平缓引导：第一人称为主，进行自我提问与引导，主要是让自我潜意识有参与感。  
6.一根针插到底的解决问题：只要内心存在疑问，就应该把问题写入问题列表，随便再进行解读。彻底明白一个系统模块，胜过离散的弄清单个问题。  
7.信息资源发散式归集：以此问题为核心支点，散发结合所有可能收集到的认知，整合解读，不唯教科书论，不唯单一信息来源论。尽量多查找一手资源。   
8.问题全流程迭代：现实3D场景->发现问题->设立标准->提出问题->描述问题信息->解决问题->实践验证->抽象化->理论化->一般化->主题框架化->重新应用于新的3D场景。 
9.导航路径：同类主题区别层面->理论层面->系列问题归集层面->实际问题解决层面       
10.细节是魔鬼，细节决定了专业的高度  
11.实现从0开始逐步构建到框架，从迭代框架实现知识的同化    

II.标准与实施设定迭代：   


&emsp;首先，做什么事之前，先要设定一下我们的小目标，
我们的整体导航路径：
1.主题解析，先难后易，深入浅出，案例拆解，举一反三。   
2.主要解决两个问题：如何思考这个问题？如何使用这个解决问题？   
3.尽可能所有收集参考资料，实践以后，再全部用自己的语言进行复述回答，将思路，事无巨细的写出来，特别是关键节点。    
4.陆续将提供中英文版本。    
5.问题解决同化迭代模式：理念与标准设定迭代模块，计划与实施迭代模块，路径框架迭代模块，问题引导列表分析迭代模块，执行分析步骤迭代模块，动画与代码实现迭代模块，方法工具归集迭代模块，反思批判迭代模块，十字定位迭代模块，意义与主题迭代模块，拓展应用迭代模块         
6.知识点主题模块同化迭代模式：理念与标准设定迭代模块，计划与实施迭代模块，路径框架迭代模块，意义背景迭代模块，十字定位迭代模块，问题引导列表分析迭代模块，区别迭代模块，反思批判迭代模块，拓展应用迭代模块       
**计划与实施迭代模块**      
将如下基础算法主题模块化  
穷举算法主题模块  
递推算法主题模块  
递归算法主题模块  
迭代算法主题模块  
贪婪算法主题模块  
分支限界算法主题模块  
分治法算法主题模块  
回溯算法主题模块  
动态规划算法主题模块 
模拟算法主题模块    
 
****问题引导列表分析迭代模块****   
# 目录
* **[I 如何才算对这个递归算法知其所以然？](#1)**      
  * **[1.寻找该递归算法的递归算法的意义](#1.1)**       
  *  这个递归算法怎么定义的？
  *  为什么需要引入这个递归算法？     
  * 这个递归算法解决了哪些问题？   
  * 这个递归算法思维理论是什么？       
  * 这个递归算法的数学原理是什么？    
  * 这个递归算法的对自我定位？    
  * **[2.寻找该递归算法的原始出处](#1.2)**   
  * 这个递归算法的原始出处是哪里？  
  * 这个递归算法的本质是什么？  
  * 这个递归算法的解决问题的本质是什么？   
  * 这个做法的本质又是什么？    
  * 到底本质上是什么东西导致了这个做法如此？    
  * 与这个问题类似的还有其它问题吗？ 
  * 这个递归算法是如何组成的？    
  * 这个递归算法是如何一步一步推导出来的？  
  * **[3.回顾整个的思维过程细节](#1.3)**  
  * 递归算法的实现细节有哪些？   
  * 如何自行分析推理出递归算法？      
  * 能否回顾整个递归算法的思维过程细节？  
  - 
    自己揣摩自己对这个递归算法的所有疑问：      
      并列表：     
    * 工具方法表 
    *   为什么要这样（为什么这是好的）？    
    *   为什么不是那样（有其它做法吗？有更好的做法吗？）？    
    *   这样做是最好的吗？（为什么？能证明吗？）    
    *   这个做法跟其它的什么做法有本质联系吗？    
    *   这个跟这个的区别是什么？    
    *   如何证明定理：看定理必看证明    
    *   为什么这种递归算法是对的？    
    *   为什么那种递归算法是错的？    
    *   为什么这种递归算法不是最优的？    
    *   证明为什么没有更优的递归算法。 
 ----  
  * **[4.反思反馈](#1.4)**      
  *  如何向一个4岁的小朋友解释这个算法？ 
  *  如何用一句话说出本质？
  *  如何在内心深处从0开始逻辑推理构建整个体系？
  *  能否一眼看出来？     
  * 能否做到逻辑自洽？    
    从理解开始，它的每一个细节都应该是完整而正确的，    
    从各个方面考虑这个这个递归算法，找出与你已有知识之间的联系。    
    考虑这个递归算法的细节，并尝试使它们尽可能地简单；    
    总结你这个递归算法的方法，并且尝试把它用于其他问题。    
  * **[5.我们能得到什么](#1.5)**         
  *   更新潜意识系统    
  *   升级思想思维系统    
  *   归集工具方法系统    
  *   理清概念区别系统        
  *   整理案例问题系统  
  *   经典好书与资源集      
* **[II.递归算法问题类型](#2)**     
  *  1.问题通用步骤及公式   
  *  2.问题类别区分   

####  引导回答
##### I 如何才算对这个递归算法知其所以然？ <span id="1"> 
 * **1.寻找该递归算法的递归算法的意义**   <span id="1.1">       
   *  这个递归算法怎么定义的？
  *  >直接或间接的调用自己的函数。即嵌套自己的函数  
  *  为什么需要引入这个递归算法？ 
  *  >因为存在这样的问题，可分解成较小规模，且重复的问题。      
  * 这个递归算法解决了哪些问题？   
  *  >重叠子结构，将一个问题分解成更小的子问题，以使我们的任务更容易和可行
  * 这个递归算法思维理论是什么？ 
  *  >数学上，数学归纳法。计算机，函数自调用，是函数的一种特殊形式。使用栈实现，但栈的深度有限制。      
  * 这个递归算法的数学原理是什么？  
   *  >数学归纳法，从f(1)到f(n)  
  * 这个递归算法的对自我定位？   
  *  >算法设计的基础算法之一，其他很多算法需要基于递归算法解决。  
  * **2.寻找该递归算法的原始出处**   <span id="1.2">   
  * 这个递归算法的原始出处是哪里？    
  * 这个递归算法的本质是什么？    
  * 这个递归算法的解决问题的本质是什么？   
  * 这个做法的本质又是什么？    
  * 到底本质上是什么东西导致了这个做法如此？    
  * 与这个问题类似的还有其它问题吗？ 
  * 这个递归算法是如何组成的？    
  * 这个递归算法是如何一步一步推导出来的？  
  * **3.回顾整个的思维过程细节**  <span id="1.3">   
  * 递归算法的实现细节有哪些？   
  * 如何自行分析推理出递归算法？      
  * 能否回顾整个递归算法的思维过程细节？  
  - 
    自己揣摩自己对这个递归算法的所有疑问：      
      并列表：     
    * 工具方法表 
    *   为什么要这样（为什么这是好的）？    
    *   为什么不是那样（有其它做法吗？有更好的做法吗？）？    
    *   这样做是最好的吗？（为什么？能证明吗？）    
    *   这个做法跟其它的什么做法有本质联系吗？    
    *   这个跟这个的区别是什么？    
    *   如何证明定理：看定理必看证明    
    *   为什么这种递归算法是对的？    
    *   为什么那种递归算法是错的？    
    *   为什么这种递归算法不是最优的？    
    *   证明为什么没有更优的递归算法。 

 ----  

  * **4.反思反馈**     <span id="1.4">    
  *  如何向一个4岁的小朋友解释这个算法？ 
  *  如何用一句话说出本质？
  *  如何在内心深处从0开始逻辑推理构建整个体系？
  *  能否一眼看出来？     
  * 能否做到逻辑自洽？    
    从理解开始，它的每一个细节都应该是完整而正确的，    
    从各个方面考虑这个这个递归算法，找出与你已有知识之间的联系。    
    考虑这个递归算法的细节，并尝试使它们尽可能地简单；    
    总结你这个递归算法的方法，并且尝试把它用于其他问题。    
  * **5.我们能得到什么**  <span id="1.5">           
  *   更新潜意识系统    
  *   升级思想思维系统    
  *   归集工具方法系统  
  * >递归，尾递归，迭代相互转化技术？

  * ######   理清概念区别系统  
  * ##### 概念
  * >尾递归：原理，函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以。"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。 
  * ##### 区别
  - 递归类型：  
   * >linear recursive 线性递归  
  Tail recursive 尾递归  
  Binary Recursive 二分递归  
  exponential recursive 指数递归  
  Nested Recursion 嵌套递归
  Mutual Recursion 相互递归  
  定义 
  linear recursive 线性递归:递归函数A每次单次调用自己的递归函数A   
  Tail recursive 尾递归：尾递归，就需要把计算过程中的中间变量作为参数。用参数传递中间的临时值。     
  Binary Recursive 二分递归：递归函数A：二次调用，有两个递归函数A  
  exponential recursive 指数递归 ： 递归函数A调用在for循环中的递归函数A。
  Nested Recursion 嵌套递归：递归函数A调用递归函数A，再用递归函数A作为参数，三次嵌套。
  Mutual Recursion 相互递归：递归函数A先调用递归函数B，递归函数B再调用递归函数A，同时建立两个递归函数的边界。

表达方式 
  linear recursive 线性递归    
```
double my_sqrt(double x, double a)
{
	double difference = a*x-x;
	if (difference < 0.0) difference = -difference;
	if (difference < EPSILON) return(a);
	else return(my_sqrt(x,(a+x/a)/2.0));
}
```
  Tail recursive 尾递归 
  ```
  int gcd(int m, int n)
{ 
	int r; 
	
	if (m < n) return gcd(n,m);

	r = m%n;
	if (r == 0) return(n);
	else return(gcd(n,r));
}

斐波那契数列第n项为例
int fibonacci(int n)
{
	if (n == 0) return 0;
	else if (n == 1) return 1;
	else return fibonacci(n-1)+fibonacci(n-2);
}
尾递归：
int fibonacci_tail(int n, int ret1, int ret2)
{
if (n == 0) return ret1;
else return fibonacci_tail(n-1, ret2, ret1 + ret2);
}
循环：
int fibonacci_cycle(int n)
{
	int fib;
	int f0 = 0;
	int f1 = 1;
	if (n == 0) return f0;
	else if (n == 1) return f1;
	else {
		for (int $i = 2; $i <= n; $i++) {
			fib = f0 + f1;
			f0 = f1;
			f1 = fib;
		}
		return fib;
	}
}

  ``` 
  Binary Recursive 二分递归 
  ```
  int choose(int n, int k)
{
	if (k == 0 || n == k) return(1);
	else return(choose(n-1,k) + choose(n-1,k-1));
}
  ```  
  exponential recursive 指数递归  
  ```
  void print_array(int arr[], int n)
{
	int i;
	for(i=0; i<n; i) printf("%d ", arr[i]);
	printf("\n");
}

void print_permutations(int arr[], int n, int i)
{
	int j, swap;
	print_array(arr, n);
	for(j=i+1; j<n; j) {
		swap = arr[i]; arr[i] = arr[j]; arr[j] = swap;
		print_permutations(arr, n, i+1);
		swap = arr[i]; arr[i] = arr[j]; arr[j] = swap;
	}
}
  ``` 
  Nested Recursion 嵌套递归  
  ```
  Ackerman's function
int ackerman(int m, int n)
{ 
	if (m == 0) return(n+1);
	else if (n == 0) return(ackerman(m-1,1));
	else return(ackerman(m-1,ackerman(m,n-1)));
}
  ``` 
  Mutual Recursion 相互递归   
  ```
  int is_even(unsigned int n)
{
	if (n==0) return 1;
	else return(is_odd(n-1));
}

int is_odd(unsigned int n)
{
	return (!iseven(n));
}
int is_even(unsigned int n)
{
	if (n % 2 == 0) return 1;
	else return 0;
}

int is_odd(unsigned int n)
{
	if (n % 2 != 0) return 1;
	else return 0;
}

  ``` 
        
  *   整理案例问题系统  
  *   经典好书与资源集      
* **II.递归算法问题类型**  <span id="2">     
  *  1.问题通用步骤及公式   
  *  2.问题类别区分   
  递归函数与函数参数之间的关系？  
  所有递归问题都可以转为尾递归吗？  
   * >  